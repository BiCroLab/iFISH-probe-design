#!/usr/bin/python3
# -*- coding: utf-8 -*-

# ------------------------------------------------------------------------------
# 
# Author: Gabriele Girelli
# Email: gigi.ga90@gmail.com
# Date: 2018-12-01
# Description: Design FISH probe using ODN databases.
# 
# ------------------------------------------------------------------------------



# ==============================================================================

import argparse
import configparser
import fish_prode as fp
import numpy as np
import os
import pandas as pd
import re
import sys
from tqdm import tqdm

parser = argparse.ArgumentParser(description = '''
Design a FISH probe in a genomic region of interest using a database of
oligonucleotides. Concisely, the script does the following:
- Identify all probe candidates
- Calculate centrality, size, and spread for each candidate
- Identify the candidate with the best first feature (featOrder), i.e.,
  max(centrality), min(size), or min(spread).
- Build a range around the best first feature value (filterThr) and filter out
  all the candidates that do not fall in it.
- Rank the remaining candidates based on the second feature (featOrder), i.e.,
  decreasing for centrality, increasing for size or spread.
- Return the top N candidates (maxProbes), with plots, tables, fasta and bed.
''', formatter_class = argparse.RawDescriptionHelpFormatter)

parser.add_argument('region', metavar = 'region', type = str,
    help = 'Region of interest in chrN:XXX,YYY format.')
parser.add_argument('database', metavar = 'database', type = str,
    help = 'Path to database folder.')
parser.add_argument('outdir', metavar = 'outputDirectory', type = str,
    help = 'Path to query output directory. Stops if it exists already.')

featureList = ['size', 'spread', 'centrality']
parser.add_argument('--order', metavar = 'featOrder', type = str,
    default = featureList, nargs = '+',
    help = '''Space-separated features, used as explained in script description.
    The available features are: centrality, size, and spread. At least 2
    features must be listed. Default: "size spread centrality".''')
parser.add_argument('--filter-thr', metavar = 'filterThr', type = float,
    default = .1, help = '''Threshold of first feature filter, used to identify
    a range around the best value (percentage range around it). Accepts values
    from 0 to 1. Default: 0.1''')
parser.add_argument('--min-d', metavar = 'minD', type = int,
    default = 10, help = 'Minimum distance between consecutive oligos.')
parser.add_argument('--n-oligo', metavar = 'nOligo', type = int,
    default = 48, help = 'Number of oligos per probe.')
parser.add_argument('--max-probes', metavar = 'maxProbes', type = int,
    default = -1, help = '''Maximum number of probe candidates to output.
            Set to -1 to retrieve all candidates. Default: -1''')

version = "0.0.1"
parser.add_argument('--version', action = 'version',
    version = f'{sys.argv[0]} v{version}')

args = parser.parse_args()

oligoDB = fp.query.OligoDatabase(args.database, False)

assert_msg = 'databases with overlapping oligos are not supported yet.'
assert not oligoDB.has_overlaps(), assert_msg

assert_msg = f'output folder already exists: {args.outdir}'
assert not os.path.isdir(args.outdir), assert_msg

roi_regexp = '^chr[0-9A-Za-z]+:[0-9]+,[0-9]+$'
assert_msg = 'the provided region does not match the expected pattern:'
assert_msg += f' "{args.region}" [chrN:XXX:YYY]'
assert type(None) != type(re.match(roi_regexp, args.region)), assert_msg

assert_msg = f'at least 2 features need, only {len(args.order)} found.'
assert 2 <= len(args.order), assert_msg
for o in args.order:
    assert_msg =  f'unrecognized feature "{o}". Should be one of {featureList}.'
    assert o in featureList, assert_msg

assert_msg = f'first filter threshold must be a fraction: {args.filter_thr}'
assert 0 <= args.filter_thr and 1 >= args.filter_thr, assert_msg

assert_msg = 'negative minimum distance between consecutive oligos: '
assert_msg += f'{args.min_d}'
assert args.min_d >= 0, assert_msg

assert args.n_oligo >= 1, f'a probe must have oligos: {args.n_oligo}'
if args.max_probes == -1:
    args.max_probes = np.inf
assert_msg = f'at least 1 probe in output: {args.max_probes}'
assert args.max_probes >= 0, assert_msg

chrom = args.region.split(":")[0]
chromStart, chromEnd = [int(x) for x in args.region.split(":")[1].split(',')]

assert_msg = f'chromosome "{chrom}" not in the database.'
assert chrom in oligoDB.chromData.keys(), assert_msg

chromData = oligoDB.chromData[chrom]

selectCondition = np.logical_and(
    chromData.iloc[:, 0] >= chromStart,
    chromData.iloc[:, 1] <= chromEnd)
selectedOligos = chromData.loc[selectCondition, :]

assert_msg = 'there are not enough oligos in the database.'
assert_msg += f' Asked for {args.n_oligo}, {selectCondition.sum()} found.'
assert args.n_oligo <= selectCondition.sum(), assert_msg

if 3 > chromData.shape[1]:
    print(" Retrieving sequences from UCSC...")
    sequences = []
    for i in tqdm(selectedOligos.index):
        region = selectedOligos.iloc[i, :2].tolist()
        regionSequence = fp.web.get_sequence_from_UCSC(
            config['DATABASE']['refGenome'], chrom, *region)
        sequences.append(regionSequence)
    selectedOligos.assign(name = pd.Series(sequences,
        index = selectedOligos.index).values)

for i in tqdm(range(0, chromData.shape[0]-args.n_oligo)):
    candidateDescription = fp.query.describe_probe(
        chromData.iloc[i:(i+args.n_oligo), :],
        [chrom, chromStart, chromEnd])

# END ==========================================================================

################################################################################
